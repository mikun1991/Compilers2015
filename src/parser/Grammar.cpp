#include "Grammar.h"
#define	LOG( RULE , LOGGED) \
if (!LOGGED) logRule(RULE); LOGGED = true;

#include <assert.h>

using namespace LexemeResources;
using namespace std;

void Grammar::setTokenStream(TokenStream* tokens)
{
	_currentTokens = tokens;
}

string Grammar::getError()
{
	string errors;
	for (string err : _errStrings){
		errors += err + "\n";
	}
	return errors;
}

//this is only used to move ahead to the next token
bool Grammar::match(){
	return _currentTokens->moveAhead();
}

//save a rule number in _ruleLog
void Grammar::logRule(int rule){
	_ruleLog.push_back(rule);
}

//print _ruleLog to std:out
void Grammar::printLog(){
	std::cout << "\nRULE LOG\n";
	for (int& x : _ruleLog) std::cout << ' ' << x;
	std::cout << '\n';
}

void Grammar::error(string expectedTokenNames)
{
	//found
	Token next;
	_currentTokens->nextToken(next);

	string found(LexemeNames[(int)next.getType()]);
	int line = next.getLineNumber();
	int column = next.getColumnNumber();

	char buffer[2048] = { 0 };
	sprintf(buffer, "ERROR - Found %s, expected %s, at line %d and column %d!!", found.c_str(), expectedTokenNames.c_str(), line, column);


	_errStrings.push_back(string(buffer));
}

void Grammar::error(TypeList expectedTypes)
{
	return error(expectedTypes.asStr());
}

LexemeType Grammar::nextTokenType() const
{
	return _currentTokens->nextTokenType();
}

Token Grammar::nextToken() const
{
	Token next;
	_currentTokens->nextToken(next);
	return next;
}

Lexeme Grammar::currentLexeme()
{
	return _currentTokens->currentLexeme();
}

/*  Rule 99, 100, 101, 102, 103, 104, 105
Parses strings in the language generated by
<Factor> -> Integer|Float|String Literal|"True"|"False"|"not" <factor>|"(" <expression> ")"
			|<FunctionIdentifier> <OptionalActualParameterList> | <VariableIdentifier> */
bool Grammar::factor(SemanticRecord& factor_rec)
{

	switch (nextTokenType())
	{
		case MP_INTEGER_LIT:
			factor_rec.addOperand(_semanticAnalyser->push( currentLexeme(), IntData));
			logRule(99);
			match();
			return true;
		case MP_FLOAT_LIT:
			factor_rec.addOperand(_semanticAnalyser->push(currentLexeme(), FloatData));
			logRule(100);
			match();
			return true;
		case MP_STRING_LIT:
			factor_rec.addOperand(_semanticAnalyser->push(currentLexeme(), StringData));
			logRule(101);
			match();
			return true;
		case MP_TRUE:
			factor_rec.addOperand(_semanticAnalyser->push(currentLexeme(), BoolData));
			logRule(102);
			match();
			return true;
		case MP_FALSE:
			factor_rec.addOperand(_semanticAnalyser->push(currentLexeme(), BoolData));
			logRule(103);
			match();
			return true;
		case MP_NOT:
			logRule(104);
			match();
			factor(factor_rec);
			return true;
		case MP_LPAREN:
			logRule(105);
			match();
			expression(factor_rec);
			if (nextTokenType() != MP_RPAREN){
				error(TypeList() << MP_RPAREN );
			}
			match();
			return true;
			
	/* DANGER, WILL ROBINSON! DANGER!
	conflict with next two cases, rules 106 and 116 both go to the same thing
	we chose rule 106 accepting <FunctionIdentifier> <OptionalActualParameterList>
	NOT rule 116 for <VariableIdentifier> */
	
		case MP_IDENTIFIER:{
			logRule(106);
			//i think if we get here then the calling function is 
			//looking for the value so we should be able to push this value to 
			//the stack
			SemanticRecord semRect;
			functionIdentifier(semRect);
			//this could be cleaned up
			factor_rec.addOperand(_semanticAnalyser->push(semRect.getNextOperandAsLexeme().getLexeme()));
			optionalActualParameterList();
			return true; }
		/*
		case MP_IDENTIFIER:
			logRule(116);
			variableIdentifier();
			return true;
		*/
		default:
			error(TypeList() << MP_INTEGER << MP_FLOAT_LIT << MP_STRING_LIT << MP_TRUE << MP_FALSE
			<< MP_NOT << MP_LPAREN << MP_IDENTIFIER);
	}
	return false;
}

/*  Rule 61
Parses strings in the language generated by
<ForStatement> -> "for" <ControlVariable> ":=" <InitialValue> <StepValue> <FinalValue> "do" <Statement> */
bool Grammar::forStatement()
{
	SemanticRecord forStatement_rec;

	switch (nextTokenType())
	{
	case MP_FOR:{
		logRule(61);
		match();
		controlVariable(forStatement_rec);
		//_semanticAnalyser->createTable(forStatement_rec.getNextId(), VoidData);
		if (nextTokenType() != MP_ASSIGN){
			error(TypeList() << MP_ASSIGN);
		}
		match();
		initialValue();
		stepValue();
		finalValue();
		if (nextTokenType() != MP_DO){
			error(TypeList() << MP_DO);
			return false;	//this step is to avoid logging the rule
		}
		match();
		SemanticRecord placeHolder;
		statement(placeHolder);
		//_semanticAnalyser->printCurrentTable();
		//_semanticAnalyser->closeTable();
		return true; }
	default:
		error(TypeList() << MP_FOR);
	}
	return false;
}

/*  Rule 94, 95, 96, 97, 98
Parses strings in the language generated by
<MultiplyingOperator> -> "*"|"/"|"div"|"mod"|"and"  */
bool Grammar::multiplyingOperator(SemanticRecord& record)
{
	switch (nextTokenType())
	{
	case MP_TIMES:{
		logRule(94);
		string command = record.showNextOperand().type() == FloatData ? "MULSF" : "MULS";
		record.addOperand(CommandOperand(command));
		match();
		return true;}
	case MP_FLOAT_DIVIDE:
		logRule(95);
		record.addOperand(CommandOperand("DIVSF", FloatData));
		match();
		return true;
	case MP_DIV:
		logRule(96);
		record.addOperand(CommandOperand("DIVS"));
		match();
		return true;
	case MP_MOD:
		logRule(97);
		record.addOperand(CommandOperand("MODS"));
		match();
		return true;
	case MP_AND:{
		logRule(98);
		string command = record.showNextOperand().type() == FloatData ? "ANDSF" : "ANDS";
		record.addOperand(CommandOperand(command));
		match();
		return true; }
	default:
		error( TypeList() << MP_TIMES << MP_FLOAT_DIVIDE << MP_DIV << MP_MOD << MP_AND );
	}
	return false;
}

/*  Rule 72
Parses strings in the language generated by
<ActualParameter> -> <OrdinalExpression> */
bool Grammar::actualParameter()
{
	switch (nextTokenType())
	{
	case MP_FALSE:
	case MP_NOT:
	case MP_TRUE:
	case MP_IDENTIFIER:
	case MP_INTEGER:
	case MP_INTEGER_LIT:
	case MP_FLOAT_LIT:
	case MP_STRING_LIT:
	case MP_LPAREN:
	case MP_MINUS:
	case MP_PLUS:
		logRule(72);
		match();
		return true;
	default:
		error(TypeList() << MP_FALSE<< MP_NOT<< MP_TRUE<< MP_IDENTIFIER<< MP_INTEGER<< MP_INTEGER_LIT <<
			MP_FLOAT_LIT<< MP_STRING_LIT<< MP_LPAREN<< MP_MINUS << MP_PLUS );
	}
	return false;
}

/*  Rule 70, 71
Parses strings in the language generated by
<ActualParameterTail> -> ","  <ActualParameter> <ActualParameterTail>
					  ->  E    */
bool Grammar::actualParameterTail()
{
	switch (nextTokenType())
	{
	case MP_COMMA://70
		logRule(70);
		match();
		actualParameter();
		actualParameterTail();
		return true;
	case MP_RPAREN://71 
		logRule(71);
		return true; //follow set character
	default:
		error(TypeList() << MP_COMMA << MP_RPAREN );
	}
	return false;
}

/*  Rule 88, 89, 90
Parses strings in the language generated by
<AddingOperator> -> "+"|"-"|"or"  */
bool Grammar::addingOperator(SemanticRecord& record)
{
	switch (nextTokenType())
	{
	case MP_PLUS:
		record.addOperand(CommandOperand("ADDS"));
		logRule(88);
		match();
		return true;
	case MP_MINUS:
		record.addOperand(CommandOperand("SUBS"));
		logRule(89);
		match();
		return true;
	case MP_OR:
		//TODO:: Find out what or does, is this a comparison
		record.addOperand(CommandOperand("SUBS"));
		logRule(90);
		match();
		return true;
	default:
		error(TypeList() << MP_PLUS << MP_MINUS << MP_OR );
	}
	return false;
}

/*  Rule 54, 55
Parses strings in the language generated by
<AssignmentStatement> ->  <VariableIdentifier> ":=" <Expression>
					  ->  <FunctionIdentifier> ":=" <Expression>       */
bool Grammar::assignmentStatement()
{
	SemanticRecord assignmentStatement_rec;
	switch (nextTokenType())
	{
	//conflict with this and following case, both go to same thing
    case MP_IDENTIFIER:{
		variableIdentifier(assignmentStatement_rec);
		if (nextTokenType() != MP_ASSIGN){
			error(TypeList() << MP_ASSIGN );
			return false;
		}
		logRule(54);
		assignmentStatement_rec.addOperand(CommandOperand("POP"));
		match();
		//dont neet to keep this value
		//because it has been pushed to the stack
		//it will be popped into the variable identifier
        SemanticRecord expressionRecord;
		expression(expressionRecord);
		_semanticAnalyser->unaryPrefixCommand(assignmentStatement_rec);
        return true;}
	/*
	case MP_IDENTIFIER:
		functionIdentifier();
		if (nextTokenType() != MP_ASSIGN){
			error(TypeList() << MP_ASSIGN );
			return false;
		}
		logRule(61);
		match();
		expression();
		return true;
	*/
	default:
		error(TypeList() << MP_IDENTIFIER);
	}
	return false;
}

/*  Rule 4
Parses strings in the language generated by
<Block> ->  <VariableDeclarationPart> <ProcedureAndFunctionDeclarationPart> <StatementPart>  */
bool Grammar::block()
{
	switch (nextTokenType())
	{
	case MP_BEGIN:
	case MP_VAR:
	case MP_FUNCTION:
	case MP_PROCEDURE:{
		logRule(4);

		variableDeclarationPart();
		procedureAndFunctionDeclarationPart();
		_semanticAnalyser->programHeading();
		statementPart();
		return true; }
	default:
		error(TypeList() << MP_BEGIN << MP_VAR << MP_FUNCTION << MP_PROCEDURE);
	}
	return false;
}

/*  Rule 111
Parses strings in the language generated by
<BooleanExpression> ->  <Expression> */
bool Grammar::booleanExpression(SemanticRecord& record)
{
	switch (nextTokenType())
	{
	case MP_FALSE:
	case MP_NOT:
	case MP_TRUE:
	case MP_IDENTIFIER:
	case MP_INTEGER:
	case MP_FIXED_LIT:
	case MP_STRING_LIT:
		logRule(111);
		expression(record);
		return true;
	case MP_LPAREN:
	case MP_MINUS:
	case MP_PLUS:
		match();
		logRule(111);
		expression(record);
		return true;
	default:
		error(TypeList() << MP_FALSE << MP_NOT << MP_TRUE 
			<< MP_IDENTIFIER << MP_INTEGER << MP_FIXED_LIT
			<< MP_STRING_LIT << MP_LPAREN << MP_MINUS << MP_PLUS );
	}
	return false;
}

/*  Rule 30
Parses strings in the language generated by
<CompoundStatement> -> "begin" <StatementSequence> "end" */
bool Grammar::compoundStatement()
{
	switch (nextTokenType())
	{
	case MP_BEGIN:
		match();
		statementSequence();
		if (nextTokenType() != MP_END){
			error(TypeList() << MP_END);
			return false;
		}
		logRule(30);
		match();
		return true;
	default:
		error(TypeList() << MP_BEGIN);
	}
	return false;
}

/*  Rule 62
Parses strings in the language generated by
<ControlVariable> ->  <VariableIdentifier> */
bool Grammar::controlVariable(SemanticRecord& controlVariable_rec)
{
	switch (nextTokenType())
	{
	case MP_IDENTIFIER:
		logRule(62);
		variableIdentifier(controlVariable_rec);
		return true;
	default:
		error(TypeList() << MP_IDENTIFIER);
	}
	return false;
}

/*  Rule 44
Parses strings in the language generated by
<EmptyStatement> ->  E   */
bool Grammar::emptyStatement()
{
	switch (nextTokenType())
	{
	case MP_END:
	case MP_UNTIL:
	case MP_SCOLON:
	case MP_ELSE:
		logRule(44);
		return true; //Epsilon...
	default:
		error(TypeList() << MP_END << MP_UNTIL << MP_SCOLON << MP_ELSE);
	}
	return false;
}

/*  Rule 73
Parses strings in the language generated by
<Expression> ->  <SimpleExpression> [OptionalRelationalPart]  */
bool Grammar::expression(SemanticRecord& record )
{
	switch(nextTokenType())
	{
	case MP_PLUS:
	case MP_MINUS:
	case MP_LPAREN:
	case MP_STRING_LIT:
	case MP_IDENTIFIER:
	case MP_FIXED_LIT:
	case MP_FLOAT_LIT:
	case MP_INTEGER_LIT:
	case MP_TRUE:
	case MP_NOT:
	case MP_FALSE:{
		logRule(73);
		SemanticRecord relationRecord;
		simpleExpression(relationRecord);
		optionalRelationalPart(relationRecord);
		record.addOperand(relationRecord.getNextOperandPointer());
		assert(relationRecord.size() == 0);
		return true; }
	default:
		error(TypeList() << MP_PLUS << MP_MINUS << MP_LPAREN << MP_STRING_LIT << 
		MP_IDENTIFIER << MP_FIXED_LIT << MP_FLOAT_LIT << MP_INTEGER_LIT << MP_TRUE << MP_NOT << MP_FALSE);
	}
	return false;
}

/*  Rule 92
Parses strings in the language generated by
<FactorTail> ->  <MultiplyingOperator> <Factor> <FactorTail> 
			 ->  E    */
bool Grammar::factorTail(SemanticRecord& factorTail_rec)
{
	switch (nextTokenType())
	{
	
	case MP_AND:
	case MP_DIV:
	case MP_MOD:
	case MP_FLOAT_DIVIDE:
	case MP_TIMES:{
		logRule(92);
		multiplyingOperator(factorTail_rec);
		SemanticRecord multiplyRight;
		factor(multiplyRight);
		factorTail(multiplyRight);
		factorTail_rec.addOperand(multiplyRight.getNextOperandPointer());

		//we should have enough now to perform the multiplcation operation
		factorTail_rec.addOperand(_semanticAnalyser->infixStackCommand(factorTail_rec));
		assert(multiplyRight.size() == 0);
		
		return true; }
	case MP_DO:
	case MP_DOWNTO:
	case MP_ELSE:
	case MP_END:
	case MP_OR:
	case MP_THEN:
	case MP_TO:
	case MP_UNTIL:
	case MP_COMMA:
	case MP_SCOLON:
	case MP_RPAREN:
	case MP_EQUAL:
	case MP_GTHAN:
	case MP_LTHAN:
	case MP_GEQUAL:
	case MP_LEQUAL:
	case MP_NEQUAL:
	case MP_PLUS:
	case MP_MINUS:
		logRule(93);
		return true;

	default:
		error(TypeList() << MP_AND << MP_DIV << MP_MOD << MP_FLOAT_DIVIDE <<
		MP_TIMES << MP_DIV << MP_DO << MP_DOWNTO << MP_ELSE << MP_END << MP_OR
		<< MP_THEN << MP_TO << MP_UNTIL << MP_COMMA << MP_SCOLON << MP_RPAREN <<
		MP_EQUAL << MP_GTHAN << MP_LTHAN << MP_GEQUAL << MP_LEQUAL << MP_NEQUAL 
		<< MP_PLUS << MP_MINUS);
	}
	return false;
}

/*  Rule 66
Parses strings in the language generated by
<FinalValue> ->  <OrdinalExpression> */
bool Grammar::finalValue()
{
	SemanticRecord finalRecord;
	switch (nextTokenType())
	{
	case MP_FALSE:
	case MP_NOT:
	case MP_TRUE:
	case MP_IDENTIFIER:
	case MP_INTEGER_LIT:
	case MP_FLOAT_LIT:
		logRule(66);
		ordinalExpression(finalRecord);
		return true;
	case MP_STRING_LIT:
	case MP_LPAREN:
	case MP_MINUS:
	case MP_PLUS:
		match();
		logRule(66);
		ordinalExpression(finalRecord);
		return true;
	default:
		error(TypeList() << MP_FALSE<< MP_NOT<< MP_IDENTIFIER<< MP_INTEGER_LIT<< 
			MP_FLOAT_LIT<< MP_STRING_LIT<< MP_LPAREN<< MP_MINUS<< MP_PLUS);
	}
	return false;
}

/*  Rule 25
Parses strings in the language generated by
<FormalParameterSection> ->  <ValueParameterSection> | <VariableParameterSection>  */
bool Grammar::formalParameterSection(SemanticRecord& formalParameterSection_rec)
{
	switch (nextTokenType())
	{
	case MP_IDENTIFIER:
		logRule(25);
		valueParameterSection(formalParameterSection_rec);
		return true;
	case MP_VAR:
		logRule(26);
		variableParameterSection(formalParameterSection_rec);
		return true;

	default:
		error(TypeList() << MP_IDENTIFIER << MP_VAR);
	}
	return false;
}

/*  Rule 23
Parses strings in the language generated by
<FormalParameterSectionTail> ->  ";" <FormalParameterSection> <FormalParameterSectionTail>
							 ->  E	*/
bool Grammar::formalParameterSectionTail(SemanticRecord& formalParameterSectionTail_rec)
{
	switch (nextTokenType())
	{
	case MP_SCOLON:
		logRule(23);
		formalParameterSection(formalParameterSectionTail_rec);
		formalParameterSectionTail(formalParameterSectionTail_rec);
		return true;
	case MP_RPAREN:
		logRule(24);
		return true;
	default:
		error(TypeList() << MP_RPAREN << MP_SCOLON);
	}
	return false;
}

/*  Rule 18
Parses strings in the language generated by
<FunctionDeclaration> -> <FunctionHeading> ";" <Block> ";" */
bool Grammar::functionDeclaration()
{
	switch (nextTokenType())
	{
	case MP_FUNCTION:
		logRule(18);
		functionHeading();
		if (nextTokenType() != MP_SCOLON){
			error(TypeList() << MP_SCOLON);
		}
		else{
			match();
			block();
			if (nextTokenType() != MP_SCOLON){
				error(TypeList() << MP_SCOLON);
			}
			else {
				match();
				_semanticAnalyser->printCurrentTable();
				_semanticAnalyser->closeTable();
				return true;
			}
		}
	default:
		error(TypeList() << MP_FUNCTION);
	}
	return false;
}

/*  Rule 20
Parses strings in the language generated by
<FunctionHeading> ->  "function" <functionIdentifier> [OptionalFormalParameterList] ":" <Type> */
bool Grammar::functionHeading()
{
	SemanticRecord functionHeading_rec;
	SemanticRecord optionalFormalParameterList_rec;  //need to create this here because need to create table first, then add these symbols

	switch (nextTokenType())
	{
		//20
	case MP_FUNCTION:
		logRule(20);
		match();
		functionIdentifier(functionHeading_rec);
		optionalFormalParameterList(optionalFormalParameterList_rec);
		if (nextTokenType() != MP_COLON){
			error(TypeList() << MP_COLON);
		}
		match();
		type(functionHeading_rec);
		//_semanticAnalyser->insertSymbol(functionHeading_rec.showNextId(), functionHeading_rec.getType()); 
		_semanticAnalyser->createTable(functionHeading_rec.getNextOperandAsLexeme());
		_semanticAnalyser->insertSymbol(optionalFormalParameterList_rec);
		return true;
	default:
		error(TypeList() << MP_FUNCTION);

	}
	return false;
}

/*  Rule 110
Parses strings in the language generated by
<FunctionIdentifier> ->  identifier */
bool Grammar::functionIdentifier(SemanticRecord& functionIdentifier_rec)
{

	switch (nextTokenType())
	{
	//110
	case MP_IDENTIFIER:
		logRule(110);
		functionIdentifier_rec.addOperand(currentLexeme());
		match();
		return true;
	default:
		error(TypeList() << MP_IDENTIFIER);
	}
	return false;
}

/*  Rule 113
Parses strings in the language generated by
<IdentifierList> -> identifier <IdentifierTail> */
bool Grammar::identifierList(SemanticRecord& identifierList_rec)
{

	switch (nextTokenType())
	{
	//113
	case MP_IDENTIFIER:
		identifierList_rec.addOperand(currentLexeme());
		logRule(113);
		match();
		identifierTail(identifierList_rec);
		return true;
	default:
		error(TypeList() << MP_IDENTIFIER);
	}
	return false;
}

/*  Rule 114
Parses strings in the language generated by
<IdentifierTail> -> "," identifier <IdentifierTail>
				 ->  E	*/
bool Grammar::identifierTail(SemanticRecord& identifierTail_rec)
{
	switch (nextTokenType())
	{
		//114
	case MP_COMMA:
		logRule(114);
		match();
		if (nextTokenType() != MP_IDENTIFIER){
			error(TypeList() << MP_IDENTIFIER);
		}
		identifierTail_rec.addOperand(currentLexeme());
		match();
		identifierTail(identifierTail_rec);
		return true;

		//epsilon - 115
	case MP_COLON:
		logRule(115);
		return true;

	default:
		error(TypeList() << MP_COMMA << MP_COLON);
	}
	return false;
}

/*  Rule 56
Parses strings in the language generated by
<IfStatement> -> "if" <BooleanExpression> "then" <Statement> [OptionalElsePart] */
bool Grammar::ifStatement()
{
	SemanticRecord ifRecord;
	switch (nextTokenType())
	{
		//56
	case MP_IF:{
		logRule(56);
		match();
		booleanExpression(ifRecord);
		int jumpLabel;
		_semanticAnalyser->ifStatementBegin(jumpLabel);
		if (nextTokenType() != MP_THEN){
			error(TypeList() << MP_THEN);
		}
		match();
		SemanticRecord statementRec;
		statement(statementRec);
		SemanticRecord elseRec;
		if (optionalElsePart()){
			_semanticAnalyser->ifStatementElse(jumpLabel, jumpLabel);
		}
		_semanticAnalyser->ifStatementEnd(jumpLabel);
		return true; }

	default:
		error(TypeList() << MP_IF);
	}
	return false;
}

/*  Rule 63
Parses strings in the language generated by
<InitialValue> -> <OrdinalExpression> */
bool Grammar::initialValue()
{
	switch (nextTokenType())
	{
	case MP_PLUS:
	case MP_MINUS:
	case MP_LPAREN:
	case MP_FALSE:
	case MP_TRUE:
	case MP_IDENTIFIER:
	case MP_NOT:
	case MP_STRING_LIT:
	case MP_FLOAT_LIT:
	case MP_INTEGER_LIT:{
		logRule(63);
		SemanticRecord placeHolder;
		ordinalExpression(placeHolder);
		return true; }
	default:
		error(TypeList() << MP_PLUS << MP_MINUS << MP_LPAREN << MP_FALSE << MP_TRUE << MP_IDENTIFIER << MP_NOT << MP_STRING_LIT << MP_FLOAT_LIT << MP_INTEGER_LIT);
	}
	return false;
}

/*  Rule 68, 69
Parses strings in the language generated by
<OptionalActualParameterList> -> "(" <ActualParameter> <ActualParameterTail> ")" 
							  ->  E		*/
bool Grammar::optionalActualParameterList()
{
	switch (nextTokenType())
	{
		case MP_LPAREN:
			logRule(68);
			match();
			actualParameter();
			actualParameterTail();
			if (nextTokenType() != MP_RPAREN) {
				error(TypeList() << MP_RPAREN);
			}
			match();
			return true;
		case MP_RPAREN:
		case MP_TIMES:
		case MP_PLUS:
		case MP_COMMA:
		case MP_MINUS:
		case MP_FLOAT_DIVIDE:
		case MP_SCOLON:
		case MP_LTHAN:
		case MP_LEQUAL:
		case MP_NEQUAL:
		case MP_EQUAL:
		case MP_GTHAN:
		case MP_GEQUAL:
		case MP_AND:
		case MP_DIV:
		case MP_DO:
		case MP_DOWNTO:
		case MP_ELSE:
		case MP_END:
		case MP_MOD:
		case MP_OR:
		case MP_THEN:
		case MP_TO:
		case MP_UNTIL:
			logRule(69);
			return true;
		default:
			error(TypeList() << MP_LPAREN << MP_RPAREN << MP_TIMES << MP_PLUS << MP_COMMA << MP_MINUS 
				<< MP_FLOAT_DIVIDE << MP_SCOLON << MP_LTHAN << MP_LEQUAL << MP_NEQUAL << MP_EQUAL 
				<< MP_GTHAN << MP_GEQUAL << MP_AND << MP_DIV << MP_DO << MP_DOWNTO << MP_ELSE << MP_END 
				<< MP_MOD << MP_OR << MP_THEN << MP_TO << MP_UNTIL);
	}
	return false;
}

/*  Rule 57
Parses strings in the language generated by
<OptionalElsePart> -> "else" <Statement> 
				   ->  E	*/
bool Grammar::optionalElsePart()
{
	switch (nextTokenType())
	{
	case MP_ELSE:{  //AMBIGUITY HERE
		logRule(57);
		match();
		SemanticRecord placeHolder;
		statement(placeHolder);
		return true; }
	case MP_SCOLON:
	case MP_END:
	case MP_UNTIL:
		logRule(58);
		return false; //changed this to return false if
		//there isnt an else part so we know to include 
		//else code if there is
	default:
		error(TypeList() << MP_ELSE << MP_SCOLON << MP_END << MP_UNTIL);
	}
	return false;
}

/*  Rule 21
Parses strings in the language generated by
<OptionalFormalParameterList> -> "(" <FormalParameterSection> <FormalParameterSectionTail> ")" 
							  ->  E		*/
bool Grammar::optionalFormalParameterList(SemanticRecord& optionalFormalParameterList_rec)
{
	switch (nextTokenType())
	{
	case MP_LPAREN:
		logRule(21);
		match();
		formalParameterSection(optionalFormalParameterList_rec);
		formalParameterSectionTail(optionalFormalParameterList_rec);
		if (nextTokenType() != MP_RPAREN){
			error(TypeList() << MP_RPAREN);
		}
		match();
		return true;
	case MP_COLON:
	case MP_SCOLON:
		logRule(22);
		return true;
	default:
		error(TypeList() << MP_LPAREN << MP_COLON << MP_SCOLON);
	}
	return false;
}

/*  Rule 74
Parses strings in the language generated by
<OptionalRelationalPart> -> <RelationalOperator> <SimpleExpression>
						 ->  E    */
bool Grammar::optionalRelationalPart(SemanticRecord& record)
{
	switch (nextTokenType())
	{
	case MP_EQUAL:
	case MP_LTHAN:
	case MP_GTHAN:
	case MP_LEQUAL:
	case MP_GEQUAL:
	case MP_NEQUAL:
		logRule(74);
		relationalOperator(record);
		simpleExpression(record);
		record.addOperand(_semanticAnalyser->infixStackCommand(record));
		//we should have enough to test
		//the equivalence now
		return true;
	case MP_RPAREN:
	case MP_COMMA:
	case MP_SCOLON:
	case MP_DO:
	case MP_DOWNTO:
	case MP_ELSE:
	case MP_END:
	case MP_THEN:
	case MP_TO:
	case MP_UNTIL:
		logRule(75);
		return true;
	default:
		error(TypeList() << MP_EQUAL << MP_LTHAN << MP_GTHAN << MP_LEQUAL << MP_GEQUAL << MP_NEQUAL 
			<< MP_RPAREN << MP_COMMA << MP_SCOLON << MP_DO << MP_DOWNTO << MP_ELSE << MP_END << MP_THEN 
			<< MP_TO << MP_UNTIL);
	}
	return false;
}

/*  Rule 85, 86, 87
Parses strings in the language generated by
<OptionalSign> -> "+"|"-"| E   */
bool Grammar::optionalSign()
{
	switch (nextTokenType())
	{
	case MP_PLUS:
		logRule(85);
		match();
		return true;
	case MP_MINUS:
		logRule(86);
		match();
		return true;
	case MP_LPAREN:
	case MP_FALSE:
	case MP_TRUE:
	case MP_IDENTIFIER:
	case MP_NOT:
	case MP_INTEGER_LIT:
	case MP_FLOAT_LIT:
	case MP_STRING_LIT:
		logRule(87);
		return true;
	default:
		error(TypeList() << MP_PLUS << MP_MINUS << MP_LPAREN << MP_FALSE << MP_TRUE << MP_IDENTIFIER << MP_NOT << MP_INTEGER_LIT << MP_FLOAT_LIT << MP_STRING_LIT);
	}
	return false;
}

/*  Rule 112
Parses strings in the language generated by
<OrdinalExpression> -> <Expression> */
bool Grammar::ordinalExpression(SemanticRecord& record)
{
	switch (nextTokenType())
	{
	case MP_PLUS:
	case MP_MINUS:
	case MP_LPAREN:
	case MP_FALSE:
	case MP_TRUE:
	case MP_IDENTIFIER:
	case MP_NOT:
	case MP_STRING_LIT:
	case MP_FLOAT_LIT:
	case MP_INTEGER_LIT:{
		SemanticRecord placeHolder;
		logRule(112);
		expression(placeHolder);
		record.addOperand(placeHolder.getNextOperandPointer());
		assert(placeHolder.size() == 0);
		return true; }
	default:
		error(TypeList() << MP_PLUS << MP_MINUS << MP_LPAREN << MP_FALSE << MP_TRUE << MP_IDENTIFIER << MP_NOT << MP_STRING_LIT << MP_FLOAT_LIT << MP_INTEGER_LIT);
	}
	return false;
}

/*  Rule 14
Parses strings in the language generated by
<ProcedureAndFunctionDeclarationPart> -> <ProcedureDeclaration> <ProcedureAndFunctionDeclarationPart>
									  -> <FunctionDeclaration> <ProcedureAndFunctionDeclarationPart>  
									  ->  E     */
bool Grammar::procedureAndFunctionDeclarationPart()
{
	switch (nextTokenType())
	{
	case MP_PROCEDURE:
		logRule(14);
		procedureDeclaration();
		procedureAndFunctionDeclarationPart();
		return true;
	case MP_FUNCTION:
		logRule(15);
		functionDeclaration();
		procedureAndFunctionDeclarationPart();
		return true;
	case MP_BEGIN:
		logRule(16);
		return true;
	default:
		error(TypeList() << MP_PROCEDURE << MP_FUNCTION << MP_BEGIN);
	}

	return false;
}

/*  Rule 17
Parses strings in the language generated by
<ProcedureDeclaration> -> <ProcedureHeading> ";" <Block> ";" */
bool Grammar::procedureDeclaration()
{
	switch (nextTokenType())
	{
	case MP_PROCEDURE:
		procedureHeading();
		if (nextTokenType() != MP_SCOLON){
			error(TypeList() << MP_SCOLON);
		}
		match();
		block();
		if (nextTokenType() != MP_SCOLON){
			error(TypeList() << MP_SCOLON);
		}
		match();
		_semanticAnalyser->printCurrentTable();
		_semanticAnalyser->closeTable();
		return true;
	default:
		error(TypeList() << MP_PROCEDURE);
	}
	return false;
}

/*  Rule 19
Parses strings in the language generated by
<ProcedureHeading> -> "procedure" <procedureIdentifier> [OptionalFormalParameterList] */
bool Grammar::procedureHeading()
{
	SemanticRecord procedureHeading_rec;
	SemanticRecord optionalFormalParameterList_rec;

	bool logged = false;
	switch (nextTokenType())
	{
	case MP_PROCEDURE:
		LOG(19 , logged)
		match(); //match "procedure"
		procedureIdentifier(procedureHeading_rec);
		//_semanticAnalyser->insertSymbol(procedureHeading_rec.showNextId(), procedureHeading_rec.getType());
		_semanticAnalyser->createTable(procedureHeading_rec.getNextOperandAsLexeme());
		optionalFormalParameterList(optionalFormalParameterList_rec);
		_semanticAnalyser->insertSymbol(optionalFormalParameterList_rec);
		return true;

	default:
		error(TypeList() << MP_PROCEDURE);
	}
	return false;
}

/*  Rule 109
Parses strings in the language generated by
<ProcedureIdentifier> -> identifier */
bool Grammar::procedureIdentifier(SemanticRecord& procedureIdentifier_rec)
{
	bool logged = false;
	switch (nextTokenType())
	{
	case MP_IDENTIFIER:
		procedureIdentifier_rec.addOperand(currentLexeme());
		LOG(109, logged)
		match();//
		return true;
	default:
		error("Error");
	}
	return false;
}

/*  Rule 67
Parses strings in the language generated by
<ProcedureStatement> -> <ProcedureIdentifier> [OptionalActualParameterList] */
bool Grammar::procedureStatement()
{
	SemanticRecord procedureStatement_rec;

	bool logged = false;
	switch (nextTokenType())
	{
	case MP_IDENTIFIER:
		LOG(67, logged);
		procedureIdentifier(procedureStatement_rec);
		optionalActualParameterList();
		return true;
	default:
		error(TypeList() << MP_IDENTIFIER);
	}
	return false;
}

/*  Rule 2
Parses strings in the language generated by
<Program> -> <ProgramHeading> ";" <Block> "." */
bool Grammar::program()
{
	bool logged = false;
	switch (nextTokenType())
	{
	case MP_PROGRAM:
		LOG(2, logged);
		programHeading();
		if (nextTokenType() != MP_SCOLON)
		{
			error(TypeList() << MP_SCOLON);
		}
		match();
		block();
		if (nextTokenType() != MP_PERIOD){
			error(TypeList() << MP_PERIOD);
		}
		match();
		_semanticAnalyser->printCurrentTable();
		_semanticAnalyser->closeTable();
		_semanticAnalyser->programTail();
		return true;

	default:
		error(TypeList() << MP_PROGRAM);
		return false;
	}
}

/*  Rule 3
Parses strings in the language generated by
<ProgramHeading> -> "program" <ProgramIdentifier> */
bool Grammar::programHeading()
{
	SemanticRecord programHeading_rec;

	bool logged = false;
	switch (nextTokenType())
	{
	case MP_PROGRAM:
		LOG(3, logged);
		match();
		//Token next = nextToken();
		programIdentifier(programHeading_rec);
		_semanticAnalyser->createTable(programHeading_rec.getNextOperandAsLexeme());

		return true; 
	default:
		error(TypeList() << MP_PROGRAM);
	}
	return false;
}

/*  Rule 107
Parses strings in the language generated by
<ProgramIdentifier> -> identifier */
bool Grammar::programIdentifier(SemanticRecord& programIdentifier_rec)
{
	//SemanticRecord programIdentifier_rec;

	bool logged = false;
	switch (nextTokenType())
	{
	case MP_IDENTIFIER:
		programIdentifier_rec.addOperand(currentLexeme(), VoidData);
		LOG(107, logged);
		match();
		return true;
	default:
		error(TypeList() << MP_IDENTIFIER);
	}
	//return false;
}

/*  Rule 48
Parses strings in the language generated by
<ReadParameter> -> <VariableIdentifier> */
bool Grammar::readParameter()
{
	SemanticRecord readParameter_rec;

	bool logged = false;
	switch (nextTokenType())
	{
	case MP_IDENTIFIER:
		LOG(48, logged);
		variableIdentifier(readParameter_rec);
		return true;
	default:
		error(TypeList() << MP_IDENTIFIER);
	}
	return false;
}

/*  Rule 46
Parses strings in the language generated by
<ReadParameterTail> -> "," <ReadParameter> <ReadParameterTail> */
bool Grammar::readParameterTail()
{
	bool logged = false;
	switch (nextTokenType())
	{
	case MP_COMMA:
		LOG(46, logged);
		match();
		readParameter();
		readParameterTail();
		return true;
		break;
	case MP_RPAREN: //follow set (epsilon)
		return true;
	default:
		error(TypeList() << MP_COMMA);
	}
	return false;
}

/*  Rule 45
Parses strings in the language generated by
<ReadStatement> -> "read" "(" <ReadParameter> <ReadParameterTail> ")" */
bool Grammar::readStatement()
{
	bool logged = false;
	switch (nextTokenType())
	{
	case MP_READ:
		LOG(45, logged);
		match(); // match "read"
		if (nextTokenType() != MP_LPAREN){
			error(TypeList() << MP_LPAREN);
		}
		match();
		readParameter();
		readParameterTail();
		if (nextTokenType() != MP_RPAREN){
			error(TypeList() << MP_RPAREN);
		}
		match();
		return true;
		break;
	default:
		error(TypeList() << MP_READ);
	}
	return false;
}

/*  Rule 76
Parses strings in the language generated by
<RelationalOperator> -> "="|"<"|">"|"<="|">="|"<>" */
bool Grammar::relationalOperator(SemanticRecord& record)
{ 
	bool logged = false;

	switch (nextTokenType())
	{
	case MP_EQUAL:{
					  logRule(76);
					  string equalCommand = record.showNextOperand().type() == MP_FLOAT ? "CMPEQSF" : "CMPEQS";
					  record.addOperand(CommandOperand(equalCommand));
					  match();
					  break; }
			
	case MP_LTHAN:{
					  logRule(77);
					  string lthanCommand = record.showNextOperand().type() == MP_FLOAT ? "CMPLTSF" : "CMPLTS";
					  record.addOperand(CommandOperand(lthanCommand));
					  match();
					  break; }
			
	case MP_GTHAN:{
					  logRule(78);
					  string gthanCommand = record.showNextOperand().type() == MP_FLOAT ? "CMPGTSF" : "CMPGTS";
					  record.addOperand(CommandOperand(gthanCommand));
					  match();
					  break; }
			
	case MP_LEQUAL:{
					   logRule(79);
					   string lequalCommand = record.showNextOperand().type() == MP_FLOAT ? "CMPLESF" : "CMPLES";
					   record.addOperand(CommandOperand(lequalCommand));
					   match();
					   break; }
		
	case MP_GEQUAL:{
					   logRule(80);
					   string gequalCommand = record.showNextOperand().type() == MP_FLOAT ? "CMPGESF" : "CMPGES";
					   record.addOperand(CommandOperand(gequalCommand));
					   match();
					   break; }
		
	case MP_NEQUAL:{
					   logRule(81);
					   string nequalCommand = record.showNextOperand().type() == MP_FLOAT ? "CMPNESF" : "CMPNES";
					   record.addOperand(CommandOperand(nequalCommand));
					   match();
					   break; }
		
	default:
		error(TypeList() << MP_EQUAL << MP_LTHAN << MP_GTHAN << MP_LEQUAL << MP_GEQUAL << MP_NEQUAL);
	}
	return false;
}

/*  Rule 59
Parses strings in the language generated by
<RepeatStatement> -> "repeat" <StatementSequence> "until" <BooleanExpression>    */
bool Grammar::repeatStatement()
{
	bool logged = false;

	SemanticRecord repeatRecord;
	switch (nextTokenType())
	{
	case MP_REPEAT:{
		int repeatBegin;
		_semanticAnalyser->repeatBegin(repeatBegin);
		LOG(59, logged)
			match();
		statementSequence();
		if (nextTokenType() != MP_UNTIL){
			error(TypeList() << MP_UNTIL);
		}
		match();
		booleanExpression(repeatRecord);
		_semanticAnalyser->repeatExit(repeatBegin);
		return true;
		break; }
	default:
		error(TypeList() << MP_REPEAT);	
	}

	return false;
}

/*  Rule 82
	Parses strings in the language generated by 
	<SimpleExpression> -> [ OptionalSign ] <Term> <TermTail>   */
bool Grammar::simpleExpression(SemanticRecord& record)
{
	SemanticRecord simpExp_rec;
	bool logged = false;

	switch (nextTokenType())
	{
	case MP_PLUS:
	case MP_MINUS:
	case MP_INTEGER_LIT:
	case MP_FLOAT_LIT:
	case MP_STRING_LIT:
	case MP_NOT:
	case MP_LPAREN:
	case MP_IDENTIFIER:
	case MP_FALSE:
	case MP_TRUE:
		//all of the above cases fall through to parse <Term> <TermTail>
		LOG(82, logged);
		optionalSign();
		term(simpExp_rec);
		termTail(simpExp_rec);
		//if term tail does anything to thes simpleExp_rec it should be collapsed
		//in the record to a single operand when it returns so we can pass it back up 
		record.addOperand(simpExp_rec.getNextOperandPointer());
		assert(simpExp_rec.size() == 0);
		return true;
	default:
		//Everythng else fails
		error(TypeList() << MP_PLUS << MP_MINUS << MP_INTEGER_LIT << MP_FLOAT_LIT 
			<< MP_STRING_LIT  << MP_NOT << MP_LPAREN << MP_IDENTIFIER << MP_FALSE <<MP_TRUE);
		return false;
	}

}

/*  Rule 34
Parses strings in the language generated by
<Statement> -> <EmptyStatement>|<CompoundStatment>|<ReadStatement>|<WriteStatement>|<AssignmentStatment>|
				<IfStatement>|<WhileStatement>|<RepeatStatement>|<ForStatement>|<ProcedureStatement> */
bool Grammar::statement(SemanticRecord& record)
{
	bool logged = false;
	switch (nextTokenType())
	{
	case MP_BEGIN:
		LOG(35, logged);
		return compoundStatement();
		break;
	case MP_ELSE:
	case MP_END:
		LOG(36, logged);
		return emptyStatement();
		break;
	case MP_FOR:
		LOG(42, logged)
		return forStatement();
		break;
	case MP_IF:
		LOG(39, logged);
		return ifStatement();
		break;
	case MP_PROCEDURE:
		LOG(43, logged);
		return procedureStatement();
		break;
	case MP_READ:
		LOG(36, logged);
		return readStatement();
		break;
	case MP_REPEAT:
		LOG(41, logged);
		return repeatStatement();
		break;
	case MP_UNTIL:
		LOG(34, logged);
		return emptyStatement();
		break;
	case MP_WHILE:
		LOG(40, logged);
		return whileStatement();
		break;
	case MP_WRITELN:
	case MP_WRITE:
		LOG(37, logged);
		return writeStatement();
		break;
	case MP_IDENTIFIER:  // AMBIGUITY IN LL1 TABLE 38 or 43
		LOG(38, logged);
		return assignmentStatement();
		break;
	default:
		error(TypeList() << MP_BEGIN << MP_ELSE << MP_END << MP_FOR << MP_IF << MP_PROCEDURE
			<< MP_READ << MP_REPEAT << MP_UNTIL <<MP_WHILE << MP_WRITELN << MP_WRITE << MP_IDENTIFIER);

	}

	return false;
}

/*  Rule 29
Parses strings in the language generated by
<StatementPart> -> <CompoundStatement> */
bool Grammar::statementPart()
{
	bool logged = false;
	
	switch (nextTokenType())
	{
	case MP_BEGIN:
		LOG(29, logged);
		return compoundStatement();
		break;

	default:
		error(TypeList() << MP_BEGIN);
	}

	return false;
}

/*  Rule 31
Parses strings in the language generated by
<StatementSequence> -> <Statement> <StatementTail> */
bool Grammar::statementSequence()
{
	bool logged = false;

	switch (nextTokenType())
	{
	case MP_BEGIN:
	case MP_END:
	case MP_FOR:
	case MP_IF:
	case MP_READ:
	case MP_REPEAT:
	case MP_UNTIL:
	case MP_WHILE:
	case MP_WRITE:
	case MP_WRITELN:
	case MP_IDENTIFIER:
	case MP_SCOLON:{
		SemanticRecord placeHolder;
		//we may wan to pass this through to "chain" these together
		LOG(31, logged);
		statement(placeHolder);
		return statementTail();
	}
	default:
		error(TypeList() << MP_BEGIN  << MP_END << MP_FOR << MP_IF << MP_READ << MP_REPEAT 
			<< MP_UNTIL << MP_WHILE << MP_WRITE << MP_WRITELN << MP_IDENTIFIER << MP_SCOLON );
	}
	return false;
}

/*  Rule 32
Parses strings in the language generated by
<StatementTail> -> ";" <Statement> <StatementTail>
				-> E */
bool Grammar::statementTail()
{
	bool logged = false;
	switch (nextTokenType())
	{
	case MP_SCOLON:{
		//thee should be independent of each other
		LOG(32, logged);
		match();
		SemanticRecord placeHolder;
		statement(placeHolder);
		return statementTail();
		break;
	}

	case MP_END://follow set of epsilon
	case MP_UNTIL:
		LOG(33, logged);
		return true;

	default:
		error(TypeList() << MP_SCOLON << MP_END << MP_UNTIL);
	}

	return false;
}

/*  Rule 64
Parses strings in the language generated by
<StepValue> -> "to" | "downto" */
bool Grammar::stepValue()
{
	switch (nextTokenType())
	{
	case MP_TO:
		logRule(64);
		return match();
		break;
	case MP_DOWNTO:
		logRule(65);
		return match();
		break;
	default:
		error(TypeList() << MP_TO << MP_DOWNTO );
	}
	return false;
}

/*  Rule 1
Parses strings in the language generated by
<SystemGoal> -> <Program> EOF */
bool Grammar::systemGoal()
{
	switch (nextTokenType())
	{
	case MP_PROGRAM:
		logRule(1);
		program();
		if (nextTokenType() == MP_EOF)
		{
			return true;
		}
	default:
		error(TypeList() << MP_PROGRAM );
	}
	return false;
}

/*  Rule 91
Parses strings in the language generated by
<Term> -> <Factor> <FactorTail> */
bool Grammar::term(SemanticRecord& term_rec)
{
	switch (nextTokenType())
	{
	case MP_INTEGER_LIT:
	case MP_FLOAT_LIT:
	case MP_STRING_LIT:
	case MP_TRUE:
	case MP_FALSE:
	case MP_NOT:
	case MP_LPAREN:
	case MP_IDENTIFIER:{
		//all of the above cases fall through to parse <Factor> <FactorTail>
		logRule(91);
		SemanticRecord termRecord;
		factor(termRecord);
		factorTail(termRecord);
		term_rec.addOperand(termRecord.getNextOperandPointer());
		assert(termRecord.size() == 0);

		return true; }

	default:
		//Everythng else fails
		error(TypeList() << MP_INTEGER << MP_FLOAT << MP_STRING << MP_TRUE << MP_FALSE << MP_NOT << MP_LPAREN << MP_IDENTIFIER);
		return false;
	}
}

/*  Rule 83
Parses strings in the language generated by
<TermTail> -> <AddingOperator> <Term> <TermTail> */
bool Grammar::termTail(SemanticRecord& record)
{
	SemanticRecord termTailRecord;
	switch (nextTokenType())
	{
	case MP_PLUS:
	case MP_MINUS:
	case MP_OR:
		logRule(83);
		addingOperator(record);
		term(record);
		termTailRecord.addOperand(_semanticAnalyser->infixStackCommand(record));
		//we should have enough to complete this command now
		// and we pass the command on to the nex part of the tail
		return termTail(termTailRecord);
	case MP_DO: //do
	case MP_DOWNTO: //downto
	case MP_ELSE: //else
	case MP_END://end
	case MP_THEN: //then
	case MP_TO: //to
	case MP_UNTIL: //until
	case MP_COMMA: //","
	case MP_SCOLON: //";"
	case MP_RPAREN:	//")"
	case MP_EQUAL:	//"="
	case MP_LTHAN:	//"<"
	case MP_GTHAN:	//">"
	case MP_LEQUAL:	//"<="
	case MP_GEQUAL:	//">="
	case MP_NEQUAL:	//"<>"
		logRule(84); //epsilon
		return true;
	default:
		error(TypeList() << MP_PLUS << MP_MINUS << MP_OR << MP_DO << MP_DOWNTO << MP_ELSE << MP_END << MP_THEN << MP_TO << MP_UNTIL << MP_COMMA << MP_SCOLON << MP_RPAREN << MP_EQUAL << MP_LTHAN << MP_GTHAN << MP_LEQUAL << MP_GEQUAL << MP_NEQUAL);
	}
	return false;
}

/*  Rule 10
Parses strings in the language generated by
<Type> -> "Integer"|"Float"|"String"|"Boolean" */
bool Grammar::type(SemanticRecord& type_rec)
{

	switch (nextTokenType())
	{
	case MP_INTEGER:
		type_rec.setType(IntData);
		logRule(10);
		return match();
	case MP_BOOLEAN:
		type_rec.setType(BoolData);
		logRule(13);
		return match();
	case MP_FLOAT:
		type_rec.setType(FloatData);
		logRule(11);
		return match();
	case MP_STRING:
		type_rec.setType(StringData);
		logRule(12);
		//all of the above cases fall through to accept
		return match();

	default:
		//Everythng else fails
		error(TypeList() << MP_INTEGER << MP_BOOLEAN << MP_FLOAT << MP_STRING );
	}

	return false;
}

/*  Rule 27
Parses strings in the language generated by
<ValueParameterSection> -> <IdentifierList> ":" <Type> */
bool Grammar::valueParameterSection(SemanticRecord& valueParameterSection_rec)
{
	switch (nextTokenType())
	{
	case MP_IDENTIFIER:
		logRule(27);
		identifierList(valueParameterSection_rec);
		if (nextTokenType() == MP_COLON)
		{
			match();
			type(valueParameterSection_rec);
			return true;
		}
		else {
			error(TypeList() << MP_COLON);
			return false;
		}
	default:
		error(TypeList() << MP_IDENTIFIER);
	}
	return false;
}

/*  Rule 9
Parses strings in the language generated by
<VariableDeclaration> -> <IdentifierList> ":" <Type> */
bool Grammar::variableDeclaration()
{
	SemanticRecord varDeclaration_rec;

	switch (nextTokenType())
	{
	case MP_IDENTIFIER:
		logRule(9);
		identifierList(varDeclaration_rec);
		if (nextTokenType() != MP_COLON){
			error(TypeList() << MP_COLON);
		}
		match();
		type(varDeclaration_rec);
		_semanticAnalyser->insertSymbol(varDeclaration_rec);
		return true;
	default:
		error(TypeList() << MP_IDENTIFIER);
	}
	return false;
}

/*  Rule 5
Parses strings in the language generated by
<VariableDeclarationPart> -> "var" <VariableDeclaration> ";" <VariableDeclarationTail>
						  ->  E  */
bool Grammar::variableDeclarationPart()
{
	switch (nextTokenType())
	{
	case MP_VAR:
		logRule(5);
		match();
		variableDeclaration();
		if (nextTokenType() != MP_SCOLON){
			error(TypeList() << MP_SCOLON);
		}
		match();
		variableDeclarationTail();
		return true;

	case MP_BEGIN:
	case MP_FUNCTION: 
	case MP_PROCEDURE:
		logRule(6);
		return true;
	default:  // epsilon
		error(TypeList() << MP_VAR << MP_BEGIN << MP_FUNCTION << MP_PROCEDURE);
	}
}

/*  Rule 7
Parses strings in the language generated by
<VariableDeclarationTail> -> <VariableDeclaration> ";" <VariableDeclarationTail> */
bool Grammar::variableDeclarationTail()
{
	switch (nextTokenType())
	{
	case MP_IDENTIFIER:
		logRule(7);
		variableDeclaration();
		if (nextTokenType() != MP_SCOLON){
			error(TypeList() << MP_SCOLON);
			return false;
		}
		else {
			match();
			variableDeclarationTail();
			return true;
		}

	case MP_BEGIN:
	case MP_FUNCTION:
	case MP_PROCEDURE:
		logRule(8);
		return true;
	default:
		error(TypeList() << MP_IDENTIFIER << MP_BEGIN << MP_FUNCTION << MP_PROCEDURE);
		return false;
	}
}

/*  Rule 108
Parses strings in the language generated by
<VariableIdentifier> -> Identifier */
bool Grammar::variableIdentifier(SemanticRecord& variableIdentifier_rec)
{
	switch (nextTokenType())
	{
	case MP_IDENTIFIER:
		logRule(108);
		variableIdentifier_rec.addOperand(currentLexeme());
		match();
		return true;
	default:
		error(TypeList() << MP_IDENTIFIER);
		return false;
	}
}

/*  Rule 28
Parses strings in the language generated by
<VariableParameterSection> -> "var" <IdentifierList> ":" <Type>  */
bool Grammar::variableParameterSection(SemanticRecord& variableParameterSection_rec)
{
	switch (nextTokenType())
	{
	case MP_VAR:
		logRule(28);
		match();
		identifierList(variableParameterSection_rec);
		if (nextTokenType() != MP_COLON){
			error(TypeList() << MP_COLON);
			return false;
		}
		else {
			match();
			type(variableParameterSection_rec);
			return true;
		}
	default:
		error(TypeList() << MP_VAR);
		return false;
	}
}

/*  Rule 60
Parses strings in the language generated by
<WhileStatement> -> "while" <BooleanExpression> "do" <Statement> */
bool Grammar::whileStatement()
{
	SemanticRecord whileRecord;
	switch (nextTokenType())
	{
	case MP_WHILE:{
		logRule(60);
		match();
		int repeatLabel;
		_semanticAnalyser->whileStatementPrecondition(repeatLabel);
		booleanExpression(whileRecord);
		int exitLabel;
		_semanticAnalyser->whileStatementPostcondition(exitLabel);
		if (nextTokenType() != MP_DO){
		error(TypeList() << MP_DO);
		return false;
		}
		else {
			match();
			SemanticRecord inLoop;
			statement(inLoop);
			_semanticAnalyser->whileStatementPostbody(repeatLabel, exitLabel);
			return true;
		}

		}
	default:
		error(TypeList() << MP_WHILE);
		return false;
	}
}

/*  Rule 53
Parses strings in the language generated by
<WriteParameter> -> <OrdinalExpression>   */
bool Grammar::writeParameter(SemanticRecord& record )
{
	switch (nextTokenType())
	{
	case MP_PLUS:
	case MP_MINUS:
	case MP_INTEGER_LIT:
	case MP_FLOAT_LIT:
	case MP_STRING_LIT:
	case MP_BOOLEAN:
	case MP_NOT:
	case MP_LPAREN:
	case MP_IDENTIFIER:
	case MP_FALSE:
	case MP_TRUE:
		logRule(53);
		ordinalExpression(record);
		_semanticAnalyser->writeCommand("WRTS");
		return true;
	default:
		error(TypeList() << MP_PLUS << MP_MINUS << MP_INTEGER_LIT << MP_FLOAT_LIT << MP_STRING_LIT << MP_BOOLEAN << MP_NOT << MP_LPAREN << MP_IDENTIFIER << MP_FALSE << MP_TRUE);
	}
	return false;
}

/*  Rule 51
Parses strings in the language generated by
<WriteParameterTail> -> "," <WriteParameter> <WriteParameterTail>
					 ->  E  */
bool Grammar::writeParameterTail(SemanticRecord& record)
{
	switch (nextTokenType())
	{
	case MP_COMMA:
		logRule(51);
		match();
		writeParameter(record);
		writeParameterTail(record);
		return true;
	case MP_RPAREN:
		logRule(52);
		return true;
	default:
		error(TypeList() << MP_COMMA << MP_RPAREN);
	}
	return false;
}

/*  Rule 49
Parses strings in the language generated by
<WriteStatement> -> "write"  "(" <WriteParameter> <WriteParameterTail> ")" 
				 -> "writeln" "(" <WriteParameter> <WriteParameterTail> ")"  */
bool Grammar::writeStatement()
{
	SemanticRecord writeRecords;
	bool log = false;
	switch (nextTokenType())
	{
	case MP_WRITE:
		LOG(49, log);
	case MP_WRITELN:{
		LOG(50, log);
		bool addLine = nextTokenType() == MP_WRITELN ? true : false;
		match();
		if (nextTokenType() != MP_LPAREN){
			error(TypeList() << MP_LPAREN);
			return false;
		}
		else {
			match();
			writeParameter(writeRecords);
			writeParameterTail(writeRecords);
			//_semanticAnalyser->writeList(writeRecords, addLine);
			_semanticAnalyser->writeCommand("WRTLN #\"\"");
			if (nextTokenType() != MP_RPAREN){
				error(TypeList() << MP_RPAREN);
				return false;
			}
			else {
				match();
				return true;
			}
		}}
	default:
		error(TypeList() << MP_WRITE << MP_WRITELN);
		return false;
	}
}